---
layout: post
title:  构造函数和析构函数
categories: C++
tags: C++ class
author: Yongsheng
---
* content
{:toc}
在C++中，创建对象时调用构造函数进行初始化，对象结束生命周期时调用析构函数进行“善后”工作。



## 一、构造函数和析构函数的由来 

程序中难以察觉的错误多是由于变量没有被正确初始化或清除造成的，而初始化和清除工作很容易被人遗忘。Bjarne Stroustrup在设计C++语言时充分考虑到了这个问题并很好地加以解决。

创建一个对象和装修二手房子一样：你得到了一块内存，前任留下的什么东西的都还留在里面，你得先清理（把内容置零）、重新装修（设置一些基础信息）之后才能入住。这个固定的、执行装修事宜的步骤就是构造函数。而通常我们搬离房子，为使下一任房主拎包入住，需要将整个房子重新打扫置零，这种操作我们称之为析构函数。

把对象的初始化工作放在构造函数中，把清除工作放在析构函数中。当创建对象时，构造函数被自动执行；当对象消亡时，析构函数自动执行。



## 二、构造函数和析构函数的特点

### 构造函数：

- 构造函数是一种特殊的成员函数，不需要用户来调用，定义对象时被自动执行。　　
- 构造函数名字与类名相同，无返回类型。　　
- 可以由用户自己定义实现，根据需要设计对数据成员进行初始化，依旧可以设置函数的默认参数。　　
- 如果我们没有定义构造函数，系统会为我们自动定义一个无参的默认构造函数的，它不对成员属性做任何操作，如果我们自己定义了构造函数，系统就不会为我们创建默认构造函数了。

在一个类中可以有多个构造函数，它们构成了函数的重载。

```c++
class solution{
	public:
    	solution(){}
    	//进行重载
    	solution(int A1,intA2,int A3): A1_(A1),A2_(A2),A3(A3){}
};
```

### 析构函数：

- 析构函数：

- 不接受参数。

- 无法指定任何返回类型（包括 void）。

- 无法使用 return 语句返回值。

- 无法声明为 const、volatile 或 static。 但是，可以为声明为 const、volatile 或 static 的对象的析构调用它们。

- 可以声明为 virtual。 通过使用虚拟析构函数，无需知道对象的类型即可销毁对象 - 使用虚函数机制调用该对象的正确析构函数。 请注意，析构函数也可以声明为抽象类的纯虚函数。

只要在析构函数中调用 delete 语句，就能确保对象运行中用 new 运算符分配的空间在对象消亡时被释放。

```c++
class solution{
	public:
		solution(){}
    	~solution(){}
};
```

#### 调用析构函数的时机：

- 使用 delete 运算符显式解除分配了使用 new 运算符分配的对象。 使用 delete 运算符解除分配对象时，将为“大多数派生对象”或为属于完整对象，但不是表示基类的子对象的对象释放内存。 此“大多数派生对象”解除分配一定仅对虚拟析构函数有效。 在类型信息与实际对象的基础类型不匹配的多重继承情况下，取消分配可能失败。

- 具有块范围的本地（自动）对象超出范围。

- 临时对象的生存期结束。

- 程序结束，并且存在全局或静态对象。

- 使用析构函数的完全限定名显式调用了析构函数。



#### 析构函数调用顺序：

当对象超出范围或被删除时，其完整析构中的事件序列如下所示：

- 将调用该类的析构函数，并且会执行该析构函数的主体。
- 按照非静态成员对象的析构函数在类声明中的显示顺序的相反顺序调用这些函数。 用于这些成员的构造的可选成员优化列表不影响构造或析构的顺序。 
- 非虚拟基类的析构函数以声明的相反顺序被调用。
- 虚拟基类的析构函数以声明的相反顺序被调用。

## 三、构造函数的分类

### 默认构造函数



### 重载构造函数



### 拷贝构造函数



### 赋值构造函数



### 移动构造函数



### 类型转换构造函数



### 继承构造函数



### 委托构造函数
